/* 실습예제 9-8 file: ptrtoary.c
[포인터 변수를 이용한 1차 배열의 원소 참조]
-배열 첫 원소의 주소를 포인터에 저장한 후 주소를 1씩 증가시키면 각각의 원소를 참조 가능

[포인터의 증감연산과 간전연산자]
-참조연산자 *의 우선순위는 ++p의 전위 증감연산자와 같고, 괄호나 p++의 후위증감연산자보다 낮다.
-연산자 *p++는 *(p++)를 의미
-*p++ -> *(p++): 포인터 p가 가리키는 주소를 1증가시키고 값을 참조 (;를 만나야 주소 1증가)
-연산식 (*p)++: 포인터 p가 가리키는 변수의 값을 참조하고 그 값을 1증가
-연산식 *++p는 *(++p): 포인터p가 가리키는 주소를 1증가시킨 후 가리키는 변수의 값을 참조
-연산식 ++*p는 ++(*p): 포인터 p가 가리키는 값을 참조하여 1증가시킨 후 참조

*/

#include <stdio.h>

int main(void)
{
	int a[4] = { 1,3,6,8 };
	int* pa = a;	//a==&a[0]

	//새로 선언한 포인터 변수를 사용
	printf("%d %d %d %d\n", *(pa), *(pa + 1), *(pa + 2), *(pa + 3));	//1 3 6 8

	//새로 선언한 포인터 변수를 배여로가 같이 사용 가능
	printf("%d %d %d %d\n", pa[0], pa[1], pa[2], pa[3]);	// 1 3 6 8

	//물론 원래 배열로도 사용 가능
	printf("%d %d %d %d\n", a[0], a[1], a[2], a[3]);	//1 3 6 8

	//물론 원래 배열 주소의 간접참조로도 가능
	printf("%d %d %d %d\n\n", *a, *(a + 1), *(a + 2), *(a + 3));	//1 3 6 8

	pa = &a[1]; //&a[1]==a+1

	//a[1]을 하나 증가시켜 출력
	printf("%d ", ++*pa);	//++(*pa), a[1]의 값 3->4

	//a[1]를 출력한 후 pa를 하나 증가시켜 a[2]를 가리키도록
	printf("%d ", *pa++);	//*(pa++), 4

	//a[2]의 값 6을 하나 감소시켜 5 출력
	printf("%d ", --*pa);	//--(*pa), a[2] 의 값 6->5

	//a[2]의 값 5를 출력하고 a[2]의 값 5->4
	printf("%d\n\n", (*pa)--);	//5

	//현재 포인터 변수 pa는 a[2]를 가리키고 있으며 다음으로 배열 모두 출력
	printf("%d %d %d %d\n", *(pa - 2), *(pa - 1), *pa, *(pa + 1));	//1 4 4 8

	getchar();

	return 0;
}